<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>GLTF Loader + Views</title>
    <style>
      body {
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        background: #111;
        color: white;
        font-family: sans-serif;
      }

      canvas {
        border: 1px solid #444;
        margin: 5px;
      }

      #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
      }

      #ui label {
        display: block;
        margin-bottom: 5px;
      }

      #info {
        position: fixed;
        top: 10px;
        right: 10px;
        font-family: sans-serif;
      }
    </style>
  </head>
  <body>
    <div>
      <div>
        <label style="height: 15px"
          >PC1
          <input id="p1" type="range" min="-2" max="2" step="0.01" value="0" />
        </label>
        <label style="height: 15px"
          >PC2
          <input id="p2" type="range" min="-2" max="2" step="0.01" value="0" />
        </label>
        <label style="height: 15px"
          >PC3
          <input id="p3" type="range" min="-2" max="2" step="0.01" value="0" />
        </label>
      </div>

      <div class="d-flex">
        <canvas id="canvas3d" width="605" height="400"></canvas>
        <canvas id="canvas3d-material" width="605" height="400"></canvas>
      </div>

      <div class="d-flex">
        <canvas id="canvasXY" width="400" height="400"></canvas>
        <canvas id="canvasXZ" width="400" height="400"></canvas>
        <canvas id="canvasYZ" width="400" height="400"></canvas>
      </div>
      <ul id="objectList"></ul>
      <div>
        <h3>Vertices</h3>
        <select id="vertexSelect" size="10" style="width: 200px"></select>
      </div>
      <div id="info">No model loaded</div>
      <div>
        <button id="loadGLTF">Load GLTF</button>
        <input type="file" id="fileInput" accept=".gltf,.glb" style="display: none" />
      </div>
    </div>

    <script type="module">
      import * as THREE from "/plugins/three/build/three.module.js";
      import { OrbitControls } from "/plugins/three/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "/plugins/three/examples/jsm/loaders/GLTFLoader.js";

      // ------------------- Utilities -------------------
      const createAxes = (length = 1) => {
        const axes = new THREE.Group();
        const colors = [0xff0000, 0x00ff00, 0x0000ff];
        const vectors = [
          new THREE.Vector3(length, 0, 0),
          new THREE.Vector3(0, length, 0),
          new THREE.Vector3(0, 0, length),
        ];
        for (let i = 0; i < 3; i++) {
          const mat = new THREE.LineBasicMaterial({ color: colors[i] });
          const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), vectors[i]]);
          axes.add(new THREE.Line(geom, mat));
        }
        return axes;
      };

      const createRenderer = (canvas, width, height) => {
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        return renderer;
      };

      const createCamera = (type, canvas, position, up = null, lookAt = new THREE.Vector3(0, 0, 0)) => {
        let camera;
        if (type === "perspective") camera = new THREE.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 100);
        else camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.copy(position);
        if (up) camera.up.copy(up);
        camera.lookAt(lookAt);
        return camera;
      };

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x888888);
      
      const sceneMat = new THREE.Scene();
      sceneMat.background = new THREE.Color(0x888888);

      // Lights for material scene
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 5, 5);
      dirLight.castShadow = true;
      sceneMat.add(ambient, dirLight);

      // ------------------- Renderers & Cameras -------------------
      const canvas3d = document.getElementById("canvas3d");
      const renderer3d = createRenderer(canvas3d, canvas3d.width, canvas3d.height);
      const camera3d = createCamera("perspective", canvas3d, new THREE.Vector3(2, 2, 4));
      const controls3d = new OrbitControls(camera3d, renderer3d.domElement);

      const canvas3dMat = document.getElementById("canvas3d-material");
      const renderer3dMat = createRenderer(canvas3dMat, canvas3dMat.width, canvas3dMat.height);
      renderer3dMat.shadowMap.enabled = true;
      renderer3dMat.shadowMap.type = THREE.PCFSoftShadowMap;
      const camera3dMat = createCamera("perspective", canvas3dMat, new THREE.Vector3(2, 2, 4));
      const controlsMat = new OrbitControls(camera3dMat, renderer3dMat.domElement);

      const rendererXY = createRenderer(document.getElementById("canvasXY"), 400, 400);
      const cameraXY = createCamera("orthographic", null, new THREE.Vector3(0, 0, 2), new THREE.Vector3(0, 1, 0));
      cameraXY.zoom = 0.7;
      cameraXY.updateProjectionMatrix();

      const rendererXZ = createRenderer(document.getElementById("canvasXZ"), 400, 400);
      const cameraXZ = createCamera("orthographic", null, new THREE.Vector3(0, 2, 0), new THREE.Vector3(0, 0, -1));
      cameraXZ.zoom = 0.7;
      cameraXZ.updateProjectionMatrix();

      const rendererYZ = createRenderer(document.getElementById("canvasYZ"), 400, 400);
      const cameraYZ = createCamera("orthographic", null, new THREE.Vector3(2, 0, 0));
      cameraYZ.zoom = 0.7;
      cameraYZ.updateProjectionMatrix();

      // Shadow plane for material scene
      const planeGeom = new THREE.PlaneGeometry(50, 50);
      const planeMat = new THREE.ShadowMaterial({ opacity: 0.5 });
      const plane = new THREE.Mesh(planeGeom, planeMat);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = 0;
      plane.receiveShadow = true;
      sceneMat.add(plane);

      const axes = createAxes(1);
      scene.add(axes);
      sceneMat.add(axes.clone());

      // ------------------- Load GLTF -------------------
      let modelGroup = new THREE.Group();
      scene.add(modelGroup);
      sceneMat.add(modelGroup.clone());

      const loader = new GLTFLoader();

      document.getElementById("loadGLTF").addEventListener("click", () => {
        document.getElementById("fileInput").click();
      });

      document.getElementById("fileInput").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const vertexSelect = document.getElementById("vertexSelect");
        let vertexSpheres = [];

        loader.load(url, (gltf) => {
          modelGroup = gltf.scene;
          scene.add(modelGroup);

          vertexSpheres.forEach((s) => scene.remove(s));
          vertexSpheres = [];
          vertexSelect.innerHTML = "";

          modelGroup.traverse((child) => {
            if (child.isMesh) {
              const positions = child.geometry.attributes.position.array;

              for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];

                const option = document.createElement("option");
                option.value = i / 3;
                option.textContent = `Vertex ${i / 3}: x=${x.toFixed(2)}, y=${y.toFixed(2)}, z=${z.toFixed(2)}`;
                vertexSelect.appendChild(option);

                const sphere = new THREE.Mesh(
                  new THREE.SphereGeometry(0.02, 8, 8),
                  new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                sphere.position.set(x, y, z);
                sphere.visible = false;
                scene.add(sphere);
                vertexSpheres.push(sphere);
              }
            }
          });
        });

        vertexSelect.addEventListener("change", () => {
          const selectedIndices = Array.from(vertexSelect.selectedOptions).map((opt) => parseInt(opt.value));

          vertexSpheres.forEach((s, i) => {
            s.visible = selectedIndices.includes(i);
          });
        });
      });

      // ------------------- Animation -------------------
      const animate = () => {
        requestAnimationFrame(animate);
        controls3d.update();
        controlsMat.update();
        renderer3d.render(scene, camera3d);
        renderer3dMat.render(sceneMat, camera3dMat);
        rendererXY.render(scene, cameraXY);
        rendererXZ.render(scene, cameraXZ);
        rendererYZ.render(scene, cameraYZ);
      };
      animate();

      window.addEventListener("resize", () => {
        renderer3d.setSize(605, 400);
        renderer3dMat.setSize(605, 400);
        [rendererXY, rendererXZ, rendererYZ].forEach((r) => r.setSize(400, 400));
      });
    </script>
  </body>
</html>
