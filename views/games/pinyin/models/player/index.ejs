<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chibi 3D Generator</title>
  <style>
    body { margin:0; font-family:system-ui, Arial; background:#111; color:#eee }
    #ui { position:fixed; left:12px; top:12px; z-index:10; display:flex; gap:8px }
    button { padding:8px 12px; border-radius:8px; border:none; cursor:pointer }
    #game { width:100vw; height:100vh; display:block }
  </style>
</head>
<body>
  <div id="ui">
    <button id="respawnBtn">Respawn</button>
    <button id="downloadBtn">Download .glb</button>
    <select id="preset" title="preset">
      <option value="cute">Cute</option>
      <option value="ninja">Ninja</option>
      <option value="wizard">Wizard</option>
    </select>
  </div>

  <div id="game"></div>

  <script type="module">
    import * as THREE from '/plugins/three/build/three.module.js';
    import { OrbitControls } from '/plugins/three/examples/jsm/controls/OrbitControls.js';
    import { GLTFExporter } from '/plugins/three/examples/jsm/exporters/GLTFExporter.js';
    import { createPlayer } from '/plugins/pinyin/models/player/model.js';

    const container = document.getElementById('game');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1b1b1b);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6.2, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,1.2,0);
    controls.enableDamping = true;

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
    hemi.position.set(0, 20, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7);
    dir.castShadow = true;
    scene.add(dir);

    const groundMat = new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.8 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    const exporter = new GLTFExporter();

    let currentChibi = null;
    function spawn(preset){
      if(currentChibi) scene.remove(currentChibi);
      const opts = {};
      opts.skinColor = (preset==='ninja')?0xffd8b0:0xffe0bd;
      opts.clothColor = (preset==='wizard')?0x6b2bff:0x5aa9ff;
      opts.hairColor = Math.random() > 0.5 ? 0x2b1b0e : 0x0b3b2f;
      opts.preset = preset;

      currentChibi = createPlayer(opts);

      const base = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.06,32), new THREE.MeshStandardMaterial({ color:0x222222, roughness:0.9 }));
      base.position.y = 0.03;
      currentChibi.add(base);

      scene.add(currentChibi);
    }

    spawn('cute');

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      if(currentChibi){
        currentChibi.rotation.y = Math.sin(t*0.6) * 0.15;
      }
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    document.getElementById('respawnBtn').addEventListener('click', () => {
      spawn(document.getElementById('preset').value);
    });

    document.getElementById('preset').addEventListener('change', () => spawn(document.getElementById('preset').value));

    document.getElementById('downloadBtn').addEventListener('click', () => {
      if(!currentChibi) return;
      const exportScene = new THREE.Scene();
      exportScene.add(currentChibi.clone(true));

      const options = { binary: true, trs: false, onlyVisible: true, truncateDrawRange: true };
      exporter.parse(exportScene, function(result){
        if(result instanceof ArrayBuffer){
          saveArrayBuffer(result, 'chibi.glb');
        } else {
          const text = JSON.stringify(result, null, 2);
          saveBlob(new Blob([text], { type: 'application/json' }), 'chibi.gltf');
        }
      }, options);
    });

    function saveBlob(blob, filename){
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      setTimeout(()=> URL.revokeObjectURL(link.href), 10000);
    }

    function saveArrayBuffer(buffer, filename){
      saveBlob(new Blob([buffer], { type: 'model/gltf-binary' }), filename);
    }
  </script>
</body>
</html>
