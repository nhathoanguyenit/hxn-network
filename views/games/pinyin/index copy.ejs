
<div>
  <div id="game"></div>
  <button id="respawnBtn" class="btn btn-primary" style="display:none;">Respawn</button>

  <script type="module">
    import * as THREE from '/plugins/three/build/three.module.js';
    import { OBJLoader } from '/plugins/three/examples/jsm/loaders/OBJLoader.js';
    import { OrbitControls } from '/plugins/three/examples/jsm/controls/OrbitControls.js';

    (() => {
      const socket = io('/pinyin', { withCredentials: true, query: { room: 'default' } });

      const respawnBtn = document.getElementById('respawnBtn');
      const gameEl = document.getElementById('game');
      const gridSize = 50;

      let players = [];
      let bombs = [];

      // --- THREE.js Setup ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(gridSize / 2, 60, gridSize / 2 + 40);
      camera.lookAt(gridSize / 2, 0, gridSize / 2);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      gameEl.appendChild(renderer.domElement);

      // --- OrbitControls for camera rotation ---
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = true;
      controls.enablePan = false;

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // --- Lights ---
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      // --- Floor ---
      const floorGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(gridSize / 2, 0, gridSize / 2);
      scene.add(floor);

      // --- Load bomb OBJ ---
      let bombTemplate;
      const loader = new OBJLoader();
      loader.load('/assets/3d-obj/model1.obj', obj => {
        // Center geometry
        const box = new THREE.Box3().setFromObject(obj);
        const center = box.getCenter(new THREE.Vector3());
        obj.position.sub(center);

        // Wrap in group for rotation
        const group = new THREE.Group();
        group.add(obj);
        group.scale.set(0.5, 0.5, 0.5);

        bombTemplate = group;
      });

      // --- Player cubes ---
      const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
      const playerMaterialSelf = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const playerMaterialOther = new THREE.MeshStandardMaterial({ color: 0xff0000 });

      const playerMeshes = new Map(); // id -> mesh
      const bombMeshes = new Map();   // id -> mesh

      // --- Animate loop ---
      function animate() {
        requestAnimationFrame(animate);

        controls.update();

        // Rotate bombs around their center
        bombMeshes.forEach(mesh => {
          mesh.rotation.y += 0.03;
          mesh.position.y = 0.5 + Math.sin(Date.now() * 0.005) * 0.05; // floating
        });

        renderer.render(scene, camera);
      }
      animate();

      // --- Update players ---
      function updatePlayers() {
        playerMeshes.forEach((mesh, id) => {
          if (!players.find(p => p.id === id)) {
            scene.remove(mesh);
            playerMeshes.delete(id);
          }
        });

        players.forEach(p => {
          let mesh = playerMeshes.get(p.id);
          if (!mesh) {
            mesh = new THREE.Mesh(playerGeometry, p.isSelf ? playerMaterialSelf : playerMaterialOther);
            scene.add(mesh);
            playerMeshes.set(p.id, mesh);
          }
          mesh.position.set(p.x + 0.5, 0.5, p.y + 0.5);
        });
      }

      // --- Update bombs ---
      function updateBombs() {
        bombMeshes.forEach((mesh, id) => {
          if (!bombs.find(b => b.id === id)) {
            scene.remove(mesh);
            bombMeshes.delete(id);
          }
        });

        bombs.forEach(bomb => {
          if (!bombMeshes.has(bomb.id) && bombTemplate) {
            const mesh = bombTemplate.clone();
            mesh.position.set(bomb.x + 0.5, 0.5, bomb.y + 0.5);
            scene.add(mesh);
            bombMeshes.set(bomb.id, mesh);
          }
        });
      }

      // --- Render everything ---
      function render() {
        updatePlayers();
        updateBombs();
      }

      // --- Socket Events ---
      socket.on('players', list => { 
        players = list.map(p => ({ ...p, isSelf: p.id === socket.id })); 
        render(); 
      });

      socket.on('bombDropped', bomb => { 
        bombs.push(bomb); 
        render(); 
      });

      socket.on('bombExploded', bomb => {
        bombs = bombs.filter(b => b.id !== bomb.id);
        render();
      });

      // --- Respawn button ---
      respawnBtn.addEventListener('click', () => socket.emit('respawn'));

      // --- Keyboard controls ---
      document.addEventListener('keydown', e => {
        const me = players.find(p => p.isSelf);
        if (!me || !me.alive) return;

        if (e.code === 'Space') { socket.emit('dropBomb'); return; }

        const keyMap = { ArrowUp:38, ArrowDown:40, ArrowLeft:37, ArrowRight:39, w:38, s:40, a:37, d:39 };
        const key = keyMap[e.key];
        if (!key) return;

        socket.emit('move', { key });
      });

    })();
  </script>
</div>